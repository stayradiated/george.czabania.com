---
title: "How I write integration tests with Vitest and Test Fixture Factory"
date: "2025-09-05 12:42"
publish: true
type: post
tags: []
description: ""
---

I love writing tests with [Vitest](https://vitest.dev/).

One of my favourite features is [Test Context](https://main.vitest.dev/guide/test-context.html).

This feature is inspired by [Playwright's Test Fixtures](https://playwright.dev/docs/test-fixtures).

## Without Text Context

An important part of an integration test is setting up the test data in a particular state - ready to be tested upon.
However, this can often balloon into many many lines of code for declaring dependencies that aren't relevant to the actual test - but rather required by the database as ppre-requisities to create the data we actually want to test.

Here is an example from [Rough.app](https://rough.app/).

I'm testing a function called `getNextPublicIdForNote`. Rough uses [ULID](https://github.com/ulid/spec)s to identify rows in our database. I love ULIDs, but they aren't very human friendly. It's much easier to refer to Document `3928` instead of Document `01K4D2CQMAN0EG015FHMZ87KZ3`. Whenever someone
creates a new Insight in Rough, we assign it an incrementing user-facing (public) ID.

This is done with the function `getNextPublicIdForNote({ db, workspaceId })`

I want to write some tests for this function.
Before I can call the function, I need to insert a new workspace into the database.
Our `workspace` column has several columns that I need to define, even though
they aren't relevant to this test at all. (I could provide any combination of
properties and it wouldn't affect the outcome of the test). This is noisy.

```typescript
import { assertOk } from '@stayradiated/error-boundary'
import { expect, test } from 'vitest'

import { WorkspaceStatus } from '#lib/enums.js'

import { getDb } from '#lib/server/db/get-db.js'
import { deleteWorkspace } from '#lib/server/db/workspace/delete-workspace.js'
import { insertWorkspace } from '#lib/server/db/workspace/insert-workspace.js'

import { $WorkspaceName } from '#lib/core/workspace/workspace-name'

import { genId } from '#lib/utils/gen-id.js'

import { getNextPublicIdForNote } from './get-next-public-id-for-note.js'

test('should start with 1', async () => {
  /* SETUP */
  const db = getDb()
  const workspace = await insertWorkspace({
    db,
    workspace: {
      id: genId(),
      icon: 'ðŸ˜€',
      name: $WorkspaceName.parse('test'),
      status: WorkspaceStatus.ACTIVE,
      publicId: `test:${genId()}`,
      version: 1,
      icp: '',
      strategy: '',
      vision: '',
      deletedAt: null,
    },
  })
  assertOk(workspace)

  /* TEST */
  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(1)

  /* TEARDOWN */
  await deleteWorkspace({ db, workspaceId: workspace.id })
})
```

This is how our test actully looks, using Test Context to automatically create
a workspace for me.

I don't need to pass any values to `useWorkspace` - as the properties don't
impact the test outcome, I can rely on defaults generated by the `useWorkspace`
helper.

The workspace is automatically cleaned up when the test completes.

```typescript
import { test as anyTest } from 'vitest'

const test = anyTest.extend<{
  db: DB,
  user: User,
}>({
  db: async ({}, use) => {
    const db = getDb()
    await use(db)
  },
  workspace: async({ db }, use) => {
    const workspace = await insertWorkspace({
      db,
      workspace: {
        id: genId(),
        icon: 'ðŸ˜€',
        name: $WorkspaceName.parse('test'),
        status: WorkspaceStatus.ACTIVE,
        publicId: `test:${genId()}`,
        version: 1,
        icp: '',
        strategy: '',
        vision: '',
        deletedAt: null,
      },
    })
    assertOk(workspace)

    await use(workspace)

    await deleteWorkspace({ db, workspaceId })
  }
})

test('should start with 1', async ({ db, workspace }) => {
  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(1)
})
```

### Rewriting Using Test Fixture Factory

```typescript
import { assertOk } from '@stayradiated/error-boundary'
import { test as anyTest, expect } from 'vitest'

import { useDb } from '#lib/test/use-db.js'
import { useWorkspace } from '#lib/test/use-workspace.js'

import { getNextPublicIdForNote } from './get-next-public-id-for-note.js'

const test = anyTest.extend({
  db: useDb(),
  workspace: useWorkspace(),
})

test('should start with 1', async ({ db, workspace }) => {
  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(1)
})
```

---

Now I want to add a note to the workspace and test that the function returns
the next highest number.

This means I have to create a new note, and provide many properties that don't
affect the test. I also have to create a new `content` row, as each `note` row
must have a piece of content it holds.

This test is now 90% setup and 10% test.

```typescript
import { assertOk } from '@stayradiated/error-boundary'
import { expect, test } from 'vitest'

import { WorkspaceStatus, NoteStatus } from '#lib/enums.js'

import { getDb } from '#lib/server/db/get-db.js'
import { deleteWorkspace } from '#lib/server/db/workspace/delete-workspace.js'
import { insertWorkspace } from '#lib/server/db/workspace/insert-workspace.js'
import { insertNote } from '#lib/server/db/note/insert-note.js'
import { insertContent } from '#lib/server/db/content/insert-content.js'

import { buildEmptyContent } from '#lib/tiptap/build-partial-content.js'

import { $WorkspaceName } from '#lib/core/workspace/workspace-name'

import { genId } from '#lib/utils/gen-id.js'

import { getNextPublicIdForNote } from './get-next-public-id-for-note.js'

test('if 1 existing note, should return 2', async () => {
  /* SETUP */
  const db = getDb()
  const workspace = await insertWorkspace({
    db,
    workspace: {
      id: genId(),
      icon: 'ðŸ˜€',
      name: $WorkspaceName.parse('test'),
      status: WorkspaceStatus.ACTIVE,
      publicId: `test:${genId()}`,
      version: 1,
      icp: '',
      strategy: '',
      vision: '',
      deletedAt: null,
    },
  })
  assertOk(workspace)

  const content = await insertContent({
    db,
    content: {
      id: genId(),
      workspaceId: workspace.id,
      ...buildEmptyContent(),
      version: 1,
    },
  })
  assertOk(content)

  const note = await insertNote({
    db,
    note: {
      id: genId(),
      workspaceId: workspace.id,
      contentId: content.id,
      lastModifiedByUserId: null,
      status: NoteStatus.ACTIVE,
      lastModifiedAt: Date.now(),
      version: 1,
      personId: null,
      referenceId: null,
      parentNoteId: null,
      sortOrder: 1,
      transcriptContentId: null,

      // NOTE: the value of this publicId impacts the test result
      publicId: 1,
    },
  })
  assertOk(note)

  /* TEST */
  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(2)

  /* TEARDOWN */
  await deleteWorkspace({ db, workspaceId: workspace.id })
})
```

```typescript
import { assertOk } from '@stayradiated/error-boundary'
import { test as anyTest, expect } from 'vitest'

import { useDb } from '#lib/test/use-db.js'
import { useCreateNote } from '#lib/test/use-note.js'
import { useWorkspace } from '#lib/test/use-workspace.js'

import { getNextPublicIdForNote } from './get-next-public-id-for-note.js'

const test = anyTest.extend({
  db: useDb(),
  workspace: useWorkspace(),
  createNote: useCreateNote(),
})

test('if 1 existing note, should return 2', async ({
  db,
  workspace,
  createNote,
}) => {
  await createNote({ publicId: 1 })

  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(2)
})
```

It gets even more verbose if I want to test with multiple notes...

The setup gets more complicated and harder to understand at a glance.

```typescript
test('if 5 existing notes, should return 6', async () => {
  /* SETUP */
  const db = getDb()
  const workspace = await insertWorkspace({
    db,
    workspace: {
      id: genId(),
      icon: 'ðŸ˜€',
      name: $WorkspaceName.parse('test'),
      status: WorkspaceStatus.ACTIVE,
      publicId: `test:${genId()}`,
      version: 1,
      icp: '',
      strategy: '',
      vision: '',
      deletedAt: null,
    },
  })
  assertOk(workspace)

  for (let i = 0; i < 5; i++) {
    const content = await insertContent({
      db,
      content: {
        id: genId(),
        workspaceId: workspace.id,
        ...buildEmptyContent(),
        version: 1,
      },
    })
    assertOk(content)

    const note = await insertNote({
      db,
      note: {
        id: genId(),
        workspaceId: workspace.id,
        contentId: content.id,
        lastModifiedByUserId: null,
        status: NoteStatus.ACTIVE,
        lastModifiedAt: Date.now(),
        version: 1,
        personId: null,
        referenceId: null,
        parentNoteId: null,
        sortOrder: i,
        transcriptContentId: null,

        // i is zero-indexed: we add 1 to start at 1
        publicId: i + 1,
      },
    })
    assertOk(note)
  }

  /* TEST */
  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(6)

  /* TEARDOWN */
  await deleteWorkspace({ db, workspaceId: workspace.id })
})
```

I could write this as:

```
test('if 5 existing notes, should return 6', async ({
  db,
  workspace,
  createNote,
}) => {
  await Promise.all([
    createNote({ publicId: 1 }),
    createNote({ publicId: 2 }),
    createNote({ publicId: 3 }),
    createNote({ publicId: 4 }),
    createNote({ publicId: 5 })
  ])

  const publicId = await getNextPublicIdForNote({
    db,
    workspaceId: workspace.id,
  })
  assertOk(publicId)

  expect(publicId).toBe(6)
})
```

---

# Test Fixtures

```typescript
const dbFactory = createFactory('DB').withValue(() => {
  const db = await getDbConnection()
  return {
    value: db,
    destroy: () => db.close()
  }
})

const userFactory = createFactory('User')
  .withContext<{ db: DB }>()
  .withValue(({ db }) => {
    const user = await createUser(db)
    return {
      value: user,
      destroy: () => deleteUser(db, user.id),
    }
  })

const test = anyTest.extend({
  db: dbFactory.useValue(),
  user: userFactory.useValue(),
})
```
