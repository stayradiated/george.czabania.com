---
title: "Focused tests with Test Fixture Factory"
slug: "focused-tests-with-vitest-and-test-fixture-factory"
date: "2025-09-24 12:00"
publish: true
type: post
tags: []
description: "Notes on the `test-fixture-factory` library and how I use it to write clean maintainable tests."
---

My favourite JavaScript framework for writing tests is [Vitest](https://vitest.dev/).

One of my favourite features is its ability to [extend the Test Context](https://main.vitest.dev/guide/test-context.html#extend-test-context) with `test.extend`. Test Context is a great way to pass in reusable fixtures to each test, which can be executed concurrently. Each fixture can have its own setup/teardown code and is only run when a test requires it. 

<Code
    code={import("./2025-09-24/example/1-vitest-example.ts?raw")}
    lang="ts"
    title="example.test.ts"
/>

## Integration Tests

When writing an integration test, you will need to set up the application state in a specific way, ready to be tested. This can often require writing many lines of code for declaring dependencies that aren't directly related to the test, but rather required by database constraints.

For example, I'm currently working on some code for [Rough.app](https://rough.app), which involves testing a function called `getNextPublicIdForDocument`.

Rough uses [ULID](https://github.com/ulid/spec)s to identify rows in our database. I love ULIDs, but they aren't very friendly to my human brain. It's much easier to refer to a Document with a number - I am more likely to recall ID `#57`, but have no chance of recognising `#01K4D2CQMAN0EG015FHMZ87KZ3`.

Whenever someone creates a new Document in Rough, we assign it a private ULID to uniquely identify it in the database, and also give it a human-friendly numeric ID, which is how we display it to the user.

Here is the function signature:

```typescript
getNextPublicIdForDocument(options: {
  db: DB,
  workspaceId: WorkspaceId
}): Promise<number | Error>
```

I want to write some tests for this function to ensure it works as expected. The ideal test would call the function and assert the result is the expected value.

Ideally, all I should need to write is:

<Code
    code={import("./2025-09-24/example/2-ideal.test.ts?raw")}
    lang="ts"
    title="get-next-public-id-for-document.test.ts"
/>

Spoiler alert: this is how our test will look at the end of this article!

However, right now, this test doesn't work - Vitest doesn't know how to provide the `db`, `workspace`, or `createDocument` fixtures yet! We will need to teach Vitest how to insert these values into the database.

Our `workspace` table has several columns that I need to define, even though they aren't at all relevant to this test. I call these properties "noise" - as I could provide any combination of values and it wouldn't affect the outcome of the test.

To test how the function behaves when there are existing `document` rows, I need to create a new `document` in the database. This also involves providing many properties that don't affect the test.

Also, due to the particular database constraints, all `document` rows must link to the `user` who created them. So I first must create a new `user` row.

As you can see below, getting this test working involves a _lot_ of setup code. Only 5% of the lines of code are actually relevant to the test; all the rest is noise.

<Code
    code={import("./2025-09-24/example/3-without-test-context.test.ts?raw")}
    lang="ts"
    title="get-next-public-id-for-document.test.ts"
/>

<Aside variant="info">
  <span slot="title">What is that <code>assertOk()</code> function?</span>

  The functions I'm working with return errors as values.

  ```typescript
  const result = await insertWorkspace({ db, workspace })

  typeof result    // Error | Workspace
  typeof result.id // Property "id" does not exist on type "Error"
  ```

  Most of the time I will manually check if the value is an error and then handle it appropriately.

  ```typescript
  const result = await insertWorkspace({ db, workspace })
  if (result instanceof Error) {
    return new Error("Failed to insert workspace", { cause: result })
  }
  typeof result.id // WorkspaceId
  ```

  However, in the test, I am happy to let the error throw if it occurs.

  ```typescript
  if (result instanceof Error) {
    throw result
  }
  ```

  To save manually typing, and to satisfy the TypeScript compiler, I use the `assertOk` function to do the above.

  ```typescript
  const result = await insertWorkspace({ db, workspace })
  assertOk(result)
  typeof result.id // WorkspaceId
  ```

</Aside>

## With Test Context

We can refactor the above tests to use Test Context to handle the setup and teardown. With this change, we use `test.extend` to declare our fixtures outside of the test.

Immediately, we see an improvement - we can reuse shared fixtures between tests, and each test only contains lines of code that are directly relevant.

<Code
    code={import("./2025-09-24/example/4-with-test-context.test.ts?raw")}
    lang="ts"
    title="get-next-public-id-for-document.test.ts"
/>

There is still a lot of setup/teardown code in this file, though. Code that will likely need to be repeated in other test files.

### With Test Fixture Factory

We can refactor our test fixtures into standalone files, so they can be used in any test. This also keeps our test files shorter, more focused, and easier to scan.

Extracting these functions into separate files can be challenging, though, especially when using TypeScript.

I've created a small library to help make this easier: [`test-fixture-factory`](https://www.npmjs.com/package/test-fixture-factory)

Here is how the test looks after being refactored to use shared fixture factory functions.

Vitest can even automatically infer the types of each fixture - I don't need to manually specify the type of the Test Context.

<Code
    code={import("./2025-09-24/example/5-with-test-fixture-factory.test.ts?raw")}
    lang="ts"
/>

Now let's have a look at how these fixture factories are defined.

### `useDb`

The simplest is `useDb`. This fixture is providing a database connection. It doesn't have any dependencies.

It simply gets a database client and returns it as the `value`. How you connect to your database is up to you. I'm using [kysely](https://kysely.dev/) here - with the setup encapsulated within the `getDb` function (which is also used by the rest of the app to use the `db`).

<Code
    code={import("./2025-09-24/lib/test/use-db.ts?raw")}
    lang="ts"
    title="use-db.ts"
/>

Here is an example of how the `useDb()` provides a `db` value to the test:

<Code
    code={import("./2025-09-24/example/6-use-db.test.ts?raw")}
    lang="ts"
    title="use-db.ts"
/>

### `useWorkspace`

Things get more interesting as we look at how to provide a `workspace` fixture.

For `useWorkspace` to work, it requires a database connection. However, instead of getting our `db` instance, we can we can declare it as a dependency.

- The `.withContext()` method is used to set the expected type of the Test Context - this is used to ensure we have type safety when accessing values in the context.
- The `.withSchema()` method declares which attributes will be provided to the factory when it's constructing a new value.
    - We set a single attribute `db`. Using the field method `.from("db")` means that this value will come from the `db` test context.

<Code
    code={import("./2025-09-24/lib/test/use-workspace.ts?raw")}
    lang="ts"
    title="use-workspace.ts"
/>

Because we declare `db` as a required dependency, the TypeScript compiler will warn us when it's missing:

```typescript
const test = baseTest.extend({
  workspace: useWorkspace(), // ⚠️ Property 'db' is missing in type …
})
```

The TypeScript compiler is satisfied when we provide the `db` fixture (using our `useDb()` factory). Now our test can receive its own unique `workspace` row - that is automatically cleaned up when the test finishes.

The factory has two key methods: `useValue` and `useCreateValue`. These methods can be passed to the Vitest Test Context. A pattern I often use is to rename and export these methods so they can be used in the test.

<Code
    code={import("./2025-09-24/example/7-use-workspace.test.ts?raw")}
    lang="ts"
    title="use-workspace.ts"
/>

### `useDocument`

Defining the `useDocument` fixture factory highlights the `test-fixture-factory` library.

To create a document, we need:

1. A `db` connection
2. A `workspaceId` value
3. A `userId` value
4. We also need to allow the test to specify the `publicId`, so it can control the test result.

Ideally, the test shouldn't need to manually pass in the `workspaceId` and `userId` values. If there is a `workspace` and a `user` available in the context, then the factory should use those.

Notice how our Test Context requires `workspace` and `user`, while our schema has slightly different names: workspaceId` and `publicId`. We use the field `.from()` method again, but this time pass a function as a second argument, which receives the test context and returns the value, so we can get the ID of the workspace.

<Code
    code={import("./2025-09-24/lib/test/use-document.ts?raw")}
    lang="ts"
    title="use-document.ts"
/>

## Wrapping Up

With the `test-fixture-factory` library, you can write clean, focused tests, now clearly expressing the intent of your tests without being drowned in implementation details.

The key benefits of this pattern are:

- Reusable fixtures across test files
- Automatic dependency resolution through the Test Context
- Type-safe composition with TypeScript inference
- Clear separation between test logic and setup code
- Automatic cleanup

If you want to try this approach in your own projects, you can find the `test-fixture-factory` library on [npm](https://www.npmjs.com/package/test-fixture-factory) and on [GitHub](https://github.com/stayradiated/test-fixture-factory).

Happy testing!
